{"version":3,"file":"51.js","mappings":"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","sources":["webpack:///../../@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js","webpack:///../../@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js","webpack:///../../@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js","webpack:///../../@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js","webpack:///../../@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js","webpack:///../../@smithy/credential-provider-imds/dist-es/error/InstanceMetadataV1FallbackError.js","webpack:///../../@smithy/credential-provider-imds/dist-es/config/Endpoint.js","webpack:///../../@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js","webpack:///../../@smithy/credential-provider-imds/dist-es/config/EndpointMode.js","webpack:///../../@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js","webpack:///../../@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js","webpack:///../../@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js","webpack:///../../@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js","webpack:///../../@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js"],"sourcesContent":["import { ProviderError } from \"@smithy/property-provider\";\nimport { Buffer } from \"buffer\";\nimport { request } from \"http\";\nexport function httpRequest(options) {\n    return new Promise((resolve, reject) => {\n        const req = request({\n            method: \"GET\",\n            ...options,\n            hostname: options.hostname?.replace(/^\\[(.+)\\]$/, \"$1\"),\n        });\n        req.on(\"error\", (err) => {\n            reject(Object.assign(new ProviderError(\"Unable to connect to instance metadata service\"), err));\n            req.destroy();\n        });\n        req.on(\"timeout\", () => {\n            reject(new ProviderError(\"TimeoutError from instance metadata service\"));\n            req.destroy();\n        });\n        req.on(\"response\", (res) => {\n            const { statusCode = 400 } = res;\n            if (statusCode < 200 || 300 <= statusCode) {\n                reject(Object.assign(new ProviderError(\"Error response received from instance metadata service\"), { statusCode }));\n                req.destroy();\n            }\n            const chunks = [];\n            res.on(\"data\", (chunk) => {\n                chunks.push(chunk);\n            });\n            res.on(\"end\", () => {\n                resolve(Buffer.concat(chunks));\n                req.destroy();\n            });\n        });\n        req.end();\n    });\n}\n","export const isImdsCredentials = (arg) => Boolean(arg) &&\n    typeof arg === \"object\" &&\n    typeof arg.AccessKeyId === \"string\" &&\n    typeof arg.SecretAccessKey === \"string\" &&\n    typeof arg.Token === \"string\" &&\n    typeof arg.Expiration === \"string\";\nexport const fromImdsCredentials = (creds) => ({\n    accessKeyId: creds.AccessKeyId,\n    secretAccessKey: creds.SecretAccessKey,\n    sessionToken: creds.Token,\n    expiration: new Date(creds.Expiration),\n});\n","export const DEFAULT_TIMEOUT = 1000;\nexport const DEFAULT_MAX_RETRIES = 0;\nexport const providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT, }) => ({ maxRetries, timeout });\n","export const retry = (toRetry, maxRetries) => {\n    let promise = toRetry();\n    for (let i = 0; i < maxRetries; i++) {\n        promise = promise.catch(toRetry);\n    }\n    return promise;\n};\n","import { CredentialsProviderError } from \"@smithy/property-provider\";\nimport { parse } from \"url\";\nimport { httpRequest } from \"./remoteProvider/httpRequest\";\nimport { fromImdsCredentials, isImdsCredentials } from \"./remoteProvider/ImdsCredentials\";\nimport { providerConfigFromInit } from \"./remoteProvider/RemoteProviderInit\";\nimport { retry } from \"./remoteProvider/retry\";\nexport const ENV_CMDS_FULL_URI = \"AWS_CONTAINER_CREDENTIALS_FULL_URI\";\nexport const ENV_CMDS_RELATIVE_URI = \"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\";\nexport const ENV_CMDS_AUTH_TOKEN = \"AWS_CONTAINER_AUTHORIZATION_TOKEN\";\nexport const fromContainerMetadata = (init = {}) => {\n    const { timeout, maxRetries } = providerConfigFromInit(init);\n    return () => retry(async () => {\n        const requestOptions = await getCmdsUri();\n        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));\n        if (!isImdsCredentials(credsResponse)) {\n            throw new CredentialsProviderError(\"Invalid response received from instance metadata service.\");\n        }\n        return fromImdsCredentials(credsResponse);\n    }, maxRetries);\n};\nconst requestFromEcsImds = async (timeout, options) => {\n    if (process.env[ENV_CMDS_AUTH_TOKEN]) {\n        options.headers = {\n            ...options.headers,\n            Authorization: process.env[ENV_CMDS_AUTH_TOKEN],\n        };\n    }\n    const buffer = await httpRequest({\n        ...options,\n        timeout,\n    });\n    return buffer.toString();\n};\nconst CMDS_IP = \"169.254.170.2\";\nconst GREENGRASS_HOSTS = {\n    localhost: true,\n    \"127.0.0.1\": true,\n};\nconst GREENGRASS_PROTOCOLS = {\n    \"http:\": true,\n    \"https:\": true,\n};\nconst getCmdsUri = async () => {\n    if (process.env[ENV_CMDS_RELATIVE_URI]) {\n        return {\n            hostname: CMDS_IP,\n            path: process.env[ENV_CMDS_RELATIVE_URI],\n        };\n    }\n    if (process.env[ENV_CMDS_FULL_URI]) {\n        const parsed = parse(process.env[ENV_CMDS_FULL_URI]);\n        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {\n            throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);\n        }\n        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {\n            throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);\n        }\n        return {\n            ...parsed,\n            port: parsed.port ? parseInt(parsed.port, 10) : undefined,\n        };\n    }\n    throw new CredentialsProviderError(\"The container metadata credential provider cannot be used unless\" +\n        ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` +\n        \" variable is set\", false);\n};\n","import { CredentialsProviderError } from \"@smithy/property-provider\";\nexport class InstanceMetadataV1FallbackError extends CredentialsProviderError {\n    constructor(message, tryNextLink = true) {\n        super(message, tryNextLink);\n        this.tryNextLink = tryNextLink;\n        this.name = \"InstanceMetadataV1FallbackError\";\n        Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);\n    }\n}\n","export var Endpoint;\n(function (Endpoint) {\n    Endpoint[\"IPv4\"] = \"http://169.254.169.254\";\n    Endpoint[\"IPv6\"] = \"http://[fd00:ec2::254]\";\n})(Endpoint || (Endpoint = {}));\n","export const ENV_ENDPOINT_NAME = \"AWS_EC2_METADATA_SERVICE_ENDPOINT\";\nexport const CONFIG_ENDPOINT_NAME = \"ec2_metadata_service_endpoint\";\nexport const ENDPOINT_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],\n    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],\n    default: undefined,\n};\n","export var EndpointMode;\n(function (EndpointMode) {\n    EndpointMode[\"IPv4\"] = \"IPv4\";\n    EndpointMode[\"IPv6\"] = \"IPv6\";\n})(EndpointMode || (EndpointMode = {}));\n","import { EndpointMode } from \"./EndpointMode\";\nexport const ENV_ENDPOINT_MODE_NAME = \"AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE\";\nexport const CONFIG_ENDPOINT_MODE_NAME = \"ec2_metadata_service_endpoint_mode\";\nexport const ENDPOINT_MODE_CONFIG_OPTIONS = {\n    environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],\n    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],\n    default: EndpointMode.IPv4,\n};\n","import { loadConfig } from \"@smithy/node-config-provider\";\nimport { parseUrl } from \"@smithy/url-parser\";\nimport { Endpoint as InstanceMetadataEndpoint } from \"../config/Endpoint\";\nimport { ENDPOINT_CONFIG_OPTIONS } from \"../config/EndpointConfigOptions\";\nimport { EndpointMode } from \"../config/EndpointMode\";\nimport { ENDPOINT_MODE_CONFIG_OPTIONS, } from \"../config/EndpointModeConfigOptions\";\nexport const getInstanceMetadataEndpoint = async () => parseUrl((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));\nconst getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)();\nconst getFromEndpointModeConfig = async () => {\n    const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();\n    switch (endpointMode) {\n        case EndpointMode.IPv4:\n            return InstanceMetadataEndpoint.IPv4;\n        case EndpointMode.IPv6:\n            return InstanceMetadataEndpoint.IPv6;\n        default:\n            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);\n    }\n};\n","const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;\nconst STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;\nconst STATIC_STABILITY_DOC_URL = \"https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html\";\nexport const getExtendedInstanceMetadataCredentials = (credentials, logger) => {\n    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +\n        Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);\n    const newExpiration = new Date(Date.now() + refreshInterval * 1000);\n    logger.warn(\"Attempting credential expiration extension due to a credential service availability issue. A refresh of these \" +\n        \"credentials will be attempted after ${new Date(newExpiration)}.\\nFor more information, please visit: \" +\n        STATIC_STABILITY_DOC_URL);\n    const originalExpiration = credentials.originalExpiration ?? credentials.expiration;\n    return {\n        ...credentials,\n        ...(originalExpiration ? { originalExpiration } : {}),\n        expiration: newExpiration,\n    };\n};\n","import { getExtendedInstanceMetadataCredentials } from \"./getExtendedInstanceMetadataCredentials\";\nexport const staticStabilityProvider = (provider, options = {}) => {\n    const logger = options?.logger || console;\n    let pastCredentials;\n    return async () => {\n        let credentials;\n        try {\n            credentials = await provider();\n            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {\n                credentials = getExtendedInstanceMetadataCredentials(credentials, logger);\n            }\n        }\n        catch (e) {\n            if (pastCredentials) {\n                logger.warn(\"Credential renew failed: \", e);\n                credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger);\n            }\n            else {\n                throw e;\n            }\n        }\n        pastCredentials = credentials;\n        return credentials;\n    };\n};\n","import { loadConfig } from \"@smithy/node-config-provider\";\nimport { CredentialsProviderError } from \"@smithy/property-provider\";\nimport { InstanceMetadataV1FallbackError } from \"./error/InstanceMetadataV1FallbackError\";\nimport { httpRequest } from \"./remoteProvider/httpRequest\";\nimport { fromImdsCredentials, isImdsCredentials } from \"./remoteProvider/ImdsCredentials\";\nimport { providerConfigFromInit } from \"./remoteProvider/RemoteProviderInit\";\nimport { retry } from \"./remoteProvider/retry\";\nimport { getInstanceMetadataEndpoint } from \"./utils/getInstanceMetadataEndpoint\";\nimport { staticStabilityProvider } from \"./utils/staticStabilityProvider\";\nconst IMDS_PATH = \"/latest/meta-data/iam/security-credentials/\";\nconst IMDS_TOKEN_PATH = \"/latest/api/token\";\nconst AWS_EC2_METADATA_V1_DISABLED = \"AWS_EC2_METADATA_V1_DISABLED\";\nconst PROFILE_AWS_EC2_METADATA_V1_DISABLED = \"ec2_metadata_v1_disabled\";\nconst X_AWS_EC2_METADATA_TOKEN = \"x-aws-ec2-metadata-token\";\nexport const fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceImdsProvider(init), { logger: init.logger });\nconst getInstanceImdsProvider = (init) => {\n    let disableFetchToken = false;\n    const { logger, profile } = init;\n    const { timeout, maxRetries } = providerConfigFromInit(init);\n    const getCredentials = async (maxRetries, options) => {\n        const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;\n        if (isImdsV1Fallback) {\n            let fallbackBlockedFromProfile = false;\n            let fallbackBlockedFromProcessEnv = false;\n            const configValue = await loadConfig({\n                environmentVariableSelector: (env) => {\n                    const envValue = env[AWS_EC2_METADATA_V1_DISABLED];\n                    fallbackBlockedFromProcessEnv = !!envValue && envValue !== \"false\";\n                    if (envValue === undefined) {\n                        throw new CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`);\n                    }\n                    return fallbackBlockedFromProcessEnv;\n                },\n                configFileSelector: (profile) => {\n                    const profileValue = profile[PROFILE_AWS_EC2_METADATA_V1_DISABLED];\n                    fallbackBlockedFromProfile = !!profileValue && profileValue !== \"false\";\n                    return fallbackBlockedFromProfile;\n                },\n                default: false,\n            }, {\n                profile,\n            })();\n            if (init.ec2MetadataV1Disabled || configValue) {\n                const causes = [];\n                if (init.ec2MetadataV1Disabled)\n                    causes.push(\"credential provider initialization (runtime option ec2MetadataV1Disabled)\");\n                if (fallbackBlockedFromProfile)\n                    causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);\n                if (fallbackBlockedFromProcessEnv)\n                    causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);\n                throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(\", \")}].`);\n            }\n        }\n        const imdsProfile = (await retry(async () => {\n            let profile;\n            try {\n                profile = await getProfile(options);\n            }\n            catch (err) {\n                if (err.statusCode === 401) {\n                    disableFetchToken = false;\n                }\n                throw err;\n            }\n            return profile;\n        }, maxRetries)).trim();\n        return retry(async () => {\n            let creds;\n            try {\n                creds = await getCredentialsFromProfile(imdsProfile, options);\n            }\n            catch (err) {\n                if (err.statusCode === 401) {\n                    disableFetchToken = false;\n                }\n                throw err;\n            }\n            return creds;\n        }, maxRetries);\n    };\n    return async () => {\n        const endpoint = await getInstanceMetadataEndpoint();\n        if (disableFetchToken) {\n            logger?.debug(\"AWS SDK Instance Metadata\", \"using v1 fallback (no token fetch)\");\n            return getCredentials(maxRetries, { ...endpoint, timeout });\n        }\n        else {\n            let token;\n            try {\n                token = (await getMetadataToken({ ...endpoint, timeout })).toString();\n            }\n            catch (error) {\n                if (error?.statusCode === 400) {\n                    throw Object.assign(error, {\n                        message: \"EC2 Metadata token request returned error\",\n                    });\n                }\n                else if (error.message === \"TimeoutError\" || [403, 404, 405].includes(error.statusCode)) {\n                    disableFetchToken = true;\n                }\n                logger?.debug(\"AWS SDK Instance Metadata\", \"using v1 fallback (initial)\");\n                return getCredentials(maxRetries, { ...endpoint, timeout });\n            }\n            return getCredentials(maxRetries, {\n                ...endpoint,\n                headers: {\n                    [X_AWS_EC2_METADATA_TOKEN]: token,\n                },\n                timeout,\n            });\n        }\n    };\n};\nconst getMetadataToken = async (options) => httpRequest({\n    ...options,\n    path: IMDS_TOKEN_PATH,\n    method: \"PUT\",\n    headers: {\n        \"x-aws-ec2-metadata-token-ttl-seconds\": \"21600\",\n    },\n});\nconst getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();\nconst getCredentialsFromProfile = async (profile, options) => {\n    const credsResponse = JSON.parse((await httpRequest({\n        ...options,\n        path: IMDS_PATH + profile,\n    })).toString());\n    if (!isImdsCredentials(credsResponse)) {\n        throw new CredentialsProviderError(\"Invalid response received from instance metadata service.\");\n    }\n    return fromImdsCredentials(credsResponse);\n};\n"],"names":["httpRequest","options","resolve","reject","req","err","res","statusCode","chunks","chunk","isImdsCredentials","arg","fromImdsCredentials","creds","DEFAULT_TIMEOUT","DEFAULT_MAX_RETRIES","providerConfigFromInit","maxRetries","timeout","retry","toRetry","promise","i","ENV_CMDS_FULL_URI","ENV_CMDS_RELATIVE_URI","ENV_CMDS_AUTH_TOKEN","fromContainerMetadata","init","requestOptions","getCmdsUri","credsResponse","requestFromEcsImds","CMDS_IP","GREENGRASS_HOSTS","GREENGRASS_PROTOCOLS","parsed","InstanceMetadataV1FallbackError","message","tryNextLink","Endpoint","ENV_ENDPOINT_NAME","CONFIG_ENDPOINT_NAME","ENDPOINT_CONFIG_OPTIONS","env","profile","EndpointMode","ENV_ENDPOINT_MODE_NAME","CONFIG_ENDPOINT_MODE_NAME","ENDPOINT_MODE_CONFIG_OPTIONS","getInstanceMetadataEndpoint","getFromEndpointConfig","getFromEndpointModeConfig","endpointMode","STATIC_STABILITY_REFRESH_INTERVAL_SECONDS","STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS","STATIC_STABILITY_DOC_URL","getExtendedInstanceMetadataCredentials","credentials","logger","refreshInterval","newExpiration","originalExpiration","staticStabilityProvider","provider","pastCredentials","e","IMDS_PATH","IMDS_TOKEN_PATH","AWS_EC2_METADATA_V1_DISABLED","PROFILE_AWS_EC2_METADATA_V1_DISABLED","X_AWS_EC2_METADATA_TOKEN","fromInstanceMetadata","getInstanceImdsProvider","disableFetchToken","getCredentials","fallbackBlockedFromProfile","fallbackBlockedFromProcessEnv","configValue","envValue","profileValue","causes","imdsProfile","getProfile","getCredentialsFromProfile","endpoint","token","getMetadataToken","error"],"sourceRoot":""}